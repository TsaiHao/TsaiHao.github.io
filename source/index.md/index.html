<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>TsaiHao&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TsaiHao&#039;s Blog"><meta name="msapplication-TileImage" content="/images/logo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TsaiHao&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="TsaiHao&#039;s Blog"><meta property="og:url" content="https://tsaihao.github.io/"><meta property="og:site_name" content="TsaiHao&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tsaihao.github.io/img/og_image.png"><meta property="article:author" content="Tsai Hao"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tsaihao.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tsaihao.github.io"},"headline":"TsaiHao's Blog","image":["https://tsaihao.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Tsai Hao"},"publisher":{"@type":"Organization","name":"TsaiHao's Blog","logo":{"@type":"ImageObject","url":"https://tsaihao.github.io/images/logo.svg"}},"description":""}</script><link rel="icon" href="/images/logo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.svg" alt="TsaiHao&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TsaiHao"><i class="zaijun&#039;s github"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-03-05T22:31:16.000Z" title="3/5/2023, 10:31:16 PM">2023-03-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-03-05T15:42:22.003Z" title="3/5/2023, 3:42:22 PM">2023-03-05</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/Self-Registration-Factory-Pattern-in-Cpp/">Self-Registration Factory Pattern in Cpp</a></h1><div class="content"><h1 id="Self-Registration-Factory-Pattern-in-C"><a href="#Self-Registration-Factory-Pattern-in-C" class="headerlink" title="Self-Registration Factory Pattern in C++"></a>Self-Registration Factory Pattern in C++</h1><h2 id="Usage-Scenarios"><a href="#Usage-Scenarios" class="headerlink" title="Usage Scenarios"></a>Usage Scenarios</h2><p>Implementing a typical factory pattern in C++ is not complicated, take the common Shape class as an example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapeFactory.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shape.h&quot;</span>        <span class="comment">// class Shape</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Triangle.h&quot;</span>     <span class="comment">// class Triangle: public Shape</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Circle.h&quot;</span>       <span class="comment">// class Circle: public Shape</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;triangle&quot;</span>) <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> <span class="built_in">Triangle</span>());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;circle&quot;</span>) <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> <span class="built_in">Circle</span>());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This method is pretty straightforward and is used more, but there are two disadvantages:</p>
<ol>
<li>Each concrete class implementation must be manually registered in the <code>ShapeFactory.cpp </code>. Over time, this file will be longer and there will be too many if-else branches eventually;</li>
<li>It is not easy to do isolation of function macros, and there will be nesting of preprocessor commands with poor readability after adding platform macros.</li>
</ol>
<p>You can dynamically generate list files such as codec_list .cin FFmpeg to solve the second problem. As a cross-platform library, FFmpeg faces the very same problem of more complex functional options. Its solution is to dynamically generate this list file for as long as possible during the configuration time. Only the enabled codec will appear in the list, which looks relatively clean.</p>
<p>This article will introduce another way to solve the above two problems: the self-registered factory pattern.</p>
<h2 id="Implementation-and-Principles"><a href="#Implementation-and-Principles" class="headerlink" title="Implementation and Principles"></a>Implementation and Principles</h2><p>Self-registration exploits the global static variable or class static member automatic initialization mechanism. In the constructor of a static variable, it will register itself into the factory method implicitly. C programming language can achieve a similar effect through <code>__attribute__ ((constructor)) </code>.</p>
<p>For example, the Shape example above can be written as:</p>
<p><em>registry.h</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ShapeType&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">registerShape</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">    ShapeFactory::<span class="built_in">instance</span>().<span class="built_in">registerShape</span>(name, []() &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> <span class="built_in">ShapeType</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>circle.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_radius = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> m_registered;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Circle::m_registered = <span class="built_in">registerShape</span>&lt;Circle&gt;(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span> * m_radius * m_radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Circle::m_registered</code> is only used to collect the return value of the registered function and ensure that it is called. The registered function call occurs before entering the main function. After entering the main function, you can directly use the factory class to create an instance.</p>
<p><em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> shape = ShapeFactory::<span class="built_in">instance</span>().<span class="built_in">createShape</span>(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (shape)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shape created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shape not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The advantage of this is obvious, since the registration of the creator takes place in the Circle source file. If we decide to disable the Circle class through the feature option, just rule out this file in the build file, no need to modify the code elsewhere, and no need to set up some functional macros to isolate the code. We don’t even need to declare Circle in a header file since there is no direct reference to this class anywhere else!</p>
<p>This method is also highly suitable for dynamic loading plug-ins during runtime. Suppose the Circle class is designed as a plug-in, the host program only needs to invoke <code>dlopen </code> function to load the <code>Circle.so</code>, and it will register itself into the list without any additional need for read information methods.</p>
<p>The sample code above can be found in different branches here:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/TsaiHao">TsaiHao</a>&#x2F;<strong><a target="_blank" rel="noopener" href="https://github.com/TsaiHao/SelfRegisterFactory">SelfRegisterFactory</a></strong></p>
<p>But this approach also inherently has some problems that are not easy to ignore. The following will introduce its shortcomings and some compromise methods.</p>
<h2 id="Problems-in-Practice"><a href="#Problems-in-Practice" class="headerlink" title="Problems in Practice"></a>Problems in Practice</h2><h3 id="Symbol-Stripping-of-Static-Linking"><a href="#Symbol-Stripping-of-Static-Linking" class="headerlink" title="Symbol Stripping of Static Linking"></a>Symbol Stripping of Static Linking</h3><p>This is the most direct problem with the self-registration method, as the cost of implementing the code unitization above. For a static library, the linker only copies the object files directly used by the program during the linking phase. Therefore, the above <code>Circle.o</code> object file will be removed without notifying because the Circle class has no code reference other than itself!</p>
<p>When we <strong>have to use static linking</strong> without giving up the self-registration method, we can:</p>
<ol>
<li><p>Use some compile options to force the link target to depend on self-registered symbols, in clang &#x2F; gcc , this option is <code>-u</code>, see <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-u-arg">Clang command line argument reference - Clang 17.0.0git documentation </a>. In the above example, add an INTERFACE link option to the shape class in CMake :</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_options</span>(shape INTERFACE -u__ZN6Circle12m_registeredE)</span><br></pre></td></tr></table></figure>

<p>After that, any target links <code>libshape.a </code> library will default rely on <code>Circle:: m_registerd</code>, thereby forcing the linker to use <code>Circle.o</code> object file.</p>
</li>
<li><p>Directly make the self-registered source file participate in the compilation of the upper-level target, that is, not compress <code>Circle.o</code> into the libshape.a library, but directly link the object file to the upper-level target as an additional subsidiary of the library. The implementation of CMake is:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(shape INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/shape/impl/Circle.cpp)</span><br></pre></td></tr></table></figure>

<p>In this way, all the targets that link the shape library will directly use <code>Circle.cpp</code> as their own source files so that the linker will not directly delete a target file such as <code>Circle.o</code>.</p>
</li>
</ol>
<p>The above two methods are highly dependent on the compilation and CMake system. If you need cross-platform you need a more general method which I have not found yet.</p>
<h3 id="The-Construction-Order-of-Static-Variables"><a href="#The-Construction-Order-of-Static-Variables" class="headerlink" title="The Construction Order of Static Variables"></a>The Construction Order of Static Variables</h3><p>Because the factory uses global variables to register, you must be careful not to rely on their order, and the relevant operations should be carried out after entering the main function as much as possible, for example:</p>
<ol>
<li>The map that holds the creator in the Factory must be a static variable in the function scope instead of the global scope;</li>
<li>Do not create or refer to this factory in the construction of other static variables.</li>
</ol>
<h3 id="Who-Are-Using-This"><a href="#Who-Are-Using-This" class="headerlink" title="Who Are Using This"></a>Who Are Using This</h3><p>Clang’s plugins and various modules of clang-tidy in <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project">Project LLVM </a> use this technique:</p>
<ol>
<li><p>Clang plugin, see <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangPlugins.html">Clang Plugins - Clang 17.0.0git documentation </a>, dynamically loaded by dlopen at runtime, after loading, the actions in the plugin are automatically registered into the list, and there is no problem with symbol elimination.</p>
</li>
<li><p>Clang-tidy module registration. A new module is registered by initializing a static variable. to solve the above problem, clang-tidy declares an <code>extern volatile int</code> variable corresponding to each module in a public header file, and the definition of the variable instance is distributed in the module’s source file. Because of the reference of this int variable, the corresponding module will not be removed by default.</p>
</li>
<li></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-18T17:25:19.000Z" title="2/18/2023, 5:25:19 PM">2023-02-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-19T05:23:58.986Z" title="2/19/2023, 5:23:58 AM">2023-02-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/">Find all simple circles in a directed graph - Johnson Algorithm</a></h1><div class="content"><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。</p>
<p><em>常用的此类算法的复杂度比较如下：</em></p>
<ul>
<li>Tiernan - O(V.const^V)</li>
<li>Tarjan - O(VEC)</li>
<li>Johnson - O(((V+E)C)</li>
<li>Szwarcfiter and Lauer - O(V+EC)</li>
</ul>
<p>所谓的简单环，即除了第一个和最后一个顶点，其余所有顶点在路径中只出现一次。这里排除了包括像v-&gt;v这样的自循环的边和在两个顶点之间的多条边的情况。本算法沿用Tiernan算法的记号，每个简单环都是由根顶点为s的子图构建的，这个子图由s和“大于”s的顶点构成。因此每个输出都根据路径的最小点s来分类。</p>
<p>当从s开始遍历路径，把一个顶点v加入这个路径时，会把这个顶点的状态设为“阻塞”（blocked），直到从v到s的所有路径都完成检索，v会一直保持这种状态，这样保证了一个顶点不会被重复添加。另外除非一个顶点是构造简单环路径的最小的点，这个点不会成为路径的根顶点。这样保证不会无意义的搜索。</p>
<p>算法的输入是一个图结构，图的表示是邻接表形式。假设每个顶点用从1到n的一个数字表示，图表示为AG，则AG(v)是一个数组表示第v个顶点的邻接顶点。算法的过程是这样的：从一个根顶点s开始构建简单环，所经过的路径的顶点保存在一个栈中。算法通过调用CIRCUIT过程添加新顶点，添加时务必将其设置为blocked，并且在过程调用返回时删除这个顶点，但是此时不一定将其阻塞状态去除。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><p>下面是算法的伪代码：<br><img src="/images/johnson_pseudo_code.png"></p>
<p>如上所述，整个算法包括CIRCUIT主过程， 位于empty stack;语句以上，它又包含一个子过程UNBLOCK用于对一个blocked顶点进行解锁。下面以C++为例谈一下我对这个算法实现的理解：</p>
<p>每个点的ID表示为1到n的一个类型为size_t整数。Ak，B两个数组在开始时被初始化，数组的长度都为n，即顶点数目。这两个数组的元素都是list<size_t>，A数组第i个元素的链表记录从点i出发指向的顶点，即图的邻接表。B的作用是记录因为此点阻塞而被迫阻塞的顶点，一旦点i因为调用unblock过程解锁，那么在B[i]链表中记录的顶点也因此解锁。B的效果是将每个点尽可能的保持阻塞状态以防止重复搜索。blocked是一个长度为n的bool数组，表示在搜索时这个点是否是阻塞。s表示目前搜索到的根结点的编号。</p>
<p>CIRCUIT过程从stack v;语句开始，其输入参数v表示这个CIRCUIT过程所搜索的环都是从v这个顶点开始的。调用开始先将标志量f设为false，f表示这次调用是否发现了一个环。把v放在栈stack中，然后将blocked数组的v设为true，即将此点阻塞。可以看到下方对于CIRCUIT的调用都是将s作为参数，所以stack的栈底一般都是s。下一步遍历Ak中第v个链表，即v出发的边指向的顶点。如果某个顶点与s相等，说明找到了一个环，这时执行输出环并把f设为true。否则如果这个顶点没有阻塞，说明还可以向下走，就递归调用此过程。</p>
<p>如果能够在v的邻接顶点中找到一条环路，则f就是true的，这时可以把v解锁，即调用unblock过程。反之，则说明从包含从v出发的边的路径都是死路，是不可能的形成环的，所以不能解锁v，同时要把与v邻接的顶点置于B数组的第v个链表中，经过v的路径是死路，但经过v的邻接顶点w的不一定死路，应为w可能有另外的上级顶点，所以如果不搜索v了，即解锁v顶点是要把B[v]中记录的顶点也解锁，以供其他路径搜索使用。</p>
<p>对v的调用结束时把v出栈。返回f，标志在这次调用中是否发现环。</p>
<p>下面是如何执行主进程。主进程涉及到寻找强连通分量(scc)，这部分可以参考tarjan算法。算法首先清空储存路径节点的栈，将搜寻起点s设为1，注意所有顶点编号从1开始。Ak初始化为在{s, s+1, s+2,…,n}这些顶点构成的子图里面所有强连通分量中，有最小顶点的分量的邻接表。Ak如果为空，说明图已经搜索完，算法结束。否则将s设为上述分量Ak里面最小的顶点，将blocked全置为false，B清空，以s为输入参数调用CIRCUIT。注意此时CIRCUIT只寻找以s开头的环路。调用完成将s加一，再在新的子图中寻找。</p>
<h2 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h2><p>下面是对上述过程的一个实例，来自YouTube一位Tushar Roy的视频主的教程（此君在YouTube上多有图论方面教程，可以学习，这个算法的视频我搬运到了B站，供诸君参考）。<br><img src="/images/johnson_step_1.png"><br>Step1是一个有向图G，Step2表示分解后的三个强连通分量，所谓强连通分量，就是在一个有向图中，任选两个顶点都可以互相到达。分解scc的tarjan算法在此不再赘述。<br><img src="/images/johnson_step_2.png"><br>发现1是最小的顶点，选取1所在的scc开始搜索，第一个调用顶点是1。step3-5是从1开始的3条遍历路径。上图所示，红色边表示搜索的路径，从1开始依次搜索1，2，3，到3的时候，栈里存储了这三个节点，并且blocked数组将这三个元素设为true。3有3个邻接顶点。首先搜索1，发现1是出发的顶点，表明找到了一个环，就将环输出，并把3这里调用的变量f设为true。<br><img src="/images/johnson_step_3.png"><br>回到顶点3后搜索下一个邻接顶点4，4没有阻塞说明还没有探索过，4只有一个邻接点5，走到5之后已经无路可走，因为5的唯一邻接顶点2处于blocked状态，所以以f为false返回这次调用，表明没有找到环。调用从2返回到5的时候看到返回值是false，这时把5放到B[2]的链表中。这种做法相当于告诉2节点：兄弟你解锁的时候把我也解锁了，你不解锁我也堵着算了，反正下次再找到我的时候，我的下家都是死路，找也是白找。所以，只有在调用UNBLOCK(2)的时候5才能解锁，这时blocked[5]还是保持blocked状态。返回的4的时候也是如此。需要把4保持阻塞，并把4放到B[5]的链表中。这时调用返回到了3节点。<br><img src="/images/johnson_step_4.png"><br>检索3的下一个邻居6，发现6的下家4还是阻塞的，于是这次调用也以失败返回。返回到3，3的邻居已经检索完，发现了一个环，所以f是true的，把3的阻塞解除，调用返回到2。因为3找到了一个环所以2的f也是true的，所以调用UNBLOCK(2)，这个过程把blocked[2]设为false之后，检索B[2]发现里面有一个元素5，因此递归调用把5也解锁了。依次调用，B就被清空了。</p>
<p>这就是一次1-&gt;2这个边开头的检索的完整过程。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] Donald B. Johnson, Finding all the elementary circuits of a directed graph, SIAM Journal on Computing, 1975.</p>
<p>[2] BiliBili搬运视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y1K7bx">https://www.bilibili.com/video/BV13Q4y1K7bx</a></p>
<p>[3] 一个Github的C++实现：<a target="_blank" rel="noopener" href="https://github.com/hellogcc/circuit-finding-algorithm%EF%BC%88%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%97%A0%E8%AE%BA%E6%96%B9%E5%BC%8F%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E9%83%BD%E6%9C%89%E4%B8%8D%E5%B0%91%E5%92%8C%E5%8E%9F%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E5%85%A5%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%89%B9%E5%88%A4%E6%80%A7%E9%89%B4%E8%B5%8F%E3%80%82">https://github.com/hellogcc/circuit-finding-algorithm（其实现无论方式还是算法都有不少和原算法的出入，大家批判性鉴赏。</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-04T10:08:01.000Z" title="12/4/2022, 10:08:01 AM">2022-12-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-18T17:22:55.011Z" title="2/18/2023, 5:22:55 PM">2023-02-18</time></span><span class="level-item"><a class="link-muted" href="/categories/blog/">blog</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/implementation_of_libcxx_any/">Introduction to std::any in c++</a></h1><div class="content"><h1 id="What-Is-std-any"><a href="#What-Is-std-any" class="headerlink" title="What Is std::any"></a>What Is <code>std::any</code></h1><p><code>std::any</code> is a new feature that comes with C++ 17 standard. It’s kind of <code>void*</code> with type-safety, supporting copy&#x2F;move&#x2F;store&#x2F;get, etc. Some basic usages of it can be found here: <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/any">std::any - cppreference</a></p>
<p>Understanding how <code>std::any</code> is implemented can be gainful, for it taking advantage of many c++ skills, especially templates.</p>
<h1 id="Implementation-of-std-any"><a href="#Implementation-of-std-any" class="headerlink" title="Implementation of std::any"></a>Implementation of <code>std::any</code></h1><p>The source code referred to below is <any> of llvm’s libcxx library, revision: <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/eb7d16ea25649909373e324e6ebf36774cabdbfa/libcxx/include/any">any - libcxx</a>.</p>
<h2 id="Class-Layout"><a href="#Class-Layout" class="headerlink" title="Class Layout"></a>Class Layout</h2><p><code>std::any</code> has two data members:</p>
<ol>
<li><p><code>__h_: _HandleFunPtr</code>, it’s a function pointer that points to a static function, as well as the entry of data manipulation including constructing&#x2F;destroying&#x2F;copying&#x2F;access, etc. Prototype of the function is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******</span></span><br><span class="line"><span class="comment">* arg1: Enum, kind of the manipulation, (_Destroy, _Copy, _Move, _Get, _TypeInfo)</span></span><br><span class="line"><span class="comment">* arg2: Caller&#x27;s &quot;this&quot; pointer</span></span><br><span class="line"><span class="comment">* arg3: Destination any, used in copy, move</span></span><br><span class="line"><span class="comment">* arg4: Runtime type info, always nullptr if rtti is disabled</span></span><br><span class="line"><span class="comment">* arg5: Fallback type info, described in next chapter</span></span><br><span class="line"><span class="comment">*******/</span></span><br><span class="line"><span class="keyword">using</span> _HandleFuncPtr =  <span class="type">void</span>* (*)(_Action, any <span class="type">const</span> *, any *, <span class="type">const</span> type_info *,</span><br><span class="line">                                        <span class="type">const</span> <span class="type">void</span>* __fallback_info);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__s_: _Storage</code>, stores pointer to managing data. It’s declared as a union for separately handling large and small objects.</p>
</li>
</ol>
<p>In conclusion, <code>std::any</code> is basically equal to an aggregate of a data block and a predefined manipulation function, which proves the famous saying <strong>Algorithms + Data Structures &#x3D; Programs</strong> to some extent.</p>
<h2 id="Skills-of-Implementation"><a href="#Skills-of-Implementation" class="headerlink" title="Skills of Implementation"></a>Skills of Implementation</h2><h3 id="Small-objects-optimization"><a href="#Small-objects-optimization" class="headerlink" title="Small objects optimization"></a>Small objects optimization</h3><blockquote>
<p>Implementations are encouraged to avoid dynamic allocations for small objects.    – cpp refrence</p>
</blockquote>
<p>The data pointer <code>__s_</code> is not a <code>void*</code> but privately declared as a such union:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _Buffer = <span class="type">aligned_storage_t</span>&lt;<span class="number">3</span>*<span class="built_in">sizeof</span>(<span class="type">void</span>*), alignment_of&lt;<span class="type">void</span>*&gt;::value&gt;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">_Storage</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> _Storage() : __ptr(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="type">void</span> *  __ptr;</span><br><span class="line">    __any_imp::_Buffer __buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In a 64-bit machine, <code>_Storage</code> occupies 24 bytes. <code>__buf</code> is equally a <code>void*</code>, used when the contained object is no larger than 24 bytes. Utilizing the benefits of stack memory, constructing or copying these small objects could be more effective. Larger objects, on the other hand, have to be stored on heap memory and allocated dynamically in runtime.</p>
<p>“24 bytes” is a curated threshold that is exactly the size of <code>std::vector</code> &#x2F;<code>std::string</code> and many other STL containers in libcxx. This fact means <code>std::any</code> can manage these common objects faster, though the memory inside them could still be dynamic.</p>
<p>A similar memory optimization technology is also applied on <code>std::string</code>, but subtler. I will introduce it in the future.</p>
<h3 id="In-place-Construct"><a href="#In-place-Construct" class="headerlink" title="In-place Construct"></a>In-place Construct</h3><p>When a <code>std::any</code> object is copied, the object managed by it is also copied. It’s pretty straight yet important, simply <code>memcpy</code> is not enough because some classes have essential things to do, such as <code>std::shared_ptr</code>. <code>std::any</code>s copy object with its own copy constructor through allocator. It also applies to move construction.</p>
<p>But what about the constructor itself? Like <code>emplace_back</code> for <code>std::vector</code>, <code>std::any</code> also has an emplace-like constructor, in which the object is directly constructed on <code>__buf</code> instead of constructing a temporary object and then moving it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::any <span class="title">a</span><span class="params">(std::in_place_type&lt;std::string&gt;, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::any <span class="title">b</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>By inspecting these 2 variables in a debugger, we can acknowledge that <code>std::in_place_type&lt;std::string&gt;</code> has two folder meanings, it tells <code>std::any</code> constructing a <code>std::string</code> instead of a <code>const char*</code> and constructing it directly.</p>
<h3 id="Type-to-int-mapping"><a href="#Type-to-int-mapping" class="headerlink" title="Type to int mapping"></a>Type to int mapping</h3><p>Obviously, <code>std::any</code> is not a template class itself, but it can throw exceptions when casting it to a different static type even if RTTI(run-time type info) is disabled. The secret of this type-safety is a mapping from type to an integer.</p>
<p>On line 162 of <code>any.h</code>, a type-unique template struct is defined as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_typeinfo</span> &#123; </span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> __id = <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get type id if rtti is disabled</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">void</span>* __get_fallback_typeid() &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;__unique_typeinfo&lt;<span class="type">remove_cv_t</span>&lt;<span class="type">remove_reference_t</span>&lt;_Tp&gt;&gt;&gt;::__id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The static member <code>__id</code> of <code>__unique_typeinfo</code> is always equal to 0 but is a unique instance corresponding to type <code>__Tp</code> due to template specialization. Based on this, <code>std::any</code> gets the address of <code>__id</code> as a fallback type id if RTTI is disabled (compiling with flag <code>-fno-rtti</code>).</p>
<h1 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h1><p>In conclusion, the best practices of <code>std::any</code> include:</p>
<ul>
<li>To avoid unnecessary copying, use <code>std::make_any</code> or <code>std::in_place_type</code> to construct.</li>
<li>Pass <code>std::any</code> by reference if possible.</li>
<li>Use pointer version <code>std::any_cast&lt;T&gt;(&amp;a)</code> to avoid copying large objects.</li>
<li>Let custom objects conform to <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rule of three&#x2F;five&#x2F;zero</a> if managed by <code>std::any</code>.</li>
</ul>
<h1 id="Formatting-of-std-any-in-LLDB"><a href="#Formatting-of-std-any-in-LLDB" class="headerlink" title="Formatting of std::any in LLDB"></a>Formatting of <code>std::any</code> in LLDB</h1><p>Both belonging to Project LLVM, LLDB does not provide a formatted display of <code>std::any</code> of libcxx (while GDB does with libstdc++). Printing <code>std::any</code> in LLDB CLI will get:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n</span><br><span class="line">Process 76235 stopped</span><br><span class="line">* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step over</span><br><span class="line">    frame #0: 0x0000000100003a3c Play`main at main.cpp:17:5</span><br><span class="line">   14          int main() &#123;</span><br><span class="line">   15              std::any a = 1;</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">16              <span class="built_in">return</span> 0;</span></span><br><span class="line">   17          &#125;</span><br><span class="line">(lldb) fr v a</span><br><span class="line">(std::any) $0 = &#123;</span><br><span class="line">  __h = 0x0000000100003d2c (Play`std::__1::__any_imp::_SmallHandler&lt;int&gt;::__handle(std::__1::__any_imp::_Action, std::__1::any const*, std::__1::any*, std::type_info const*, void const*) at any:350)</span><br><span class="line">  __s = &#123;</span><br><span class="line">    __ptr = 0x0000000000000001</span><br><span class="line">    __buf = (__lx = &quot;\U00000001\0\0\0\0\0\0\0\U00000001\0\xc1\x89FͽV\0:\0\0\U00000001&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It takes seconds to understand “a” is an int (from _SmallHandler’s type) and its value is 0x1 (from first 4 bytes of <code>__buf</code>). I write a Python script as a plugin based on LLDB API to print it more intuitively. </p>
<script src="https://gist.github.com/TsaiHao/a0abaaa7272c917d5fc00e2bdc676969.js"></script>

<h2 id="Implementation-of-plugin"><a href="#Implementation-of-plugin" class="headerlink" title="Implementation of plugin"></a>Implementation of plugin</h2><p>There are 2 functions inside this script. <code>__lldb_init_module</code> is the entry of this plugin. <code>handle_std_any</code> is the processing handle used by LLDB.</p>
<p>A tricky skill is catching the type name inside <code>_SmallHandler</code> using regex. After knowing that, we can find the object representing this type in python and then forcibly convert the pointer of buffer to it. This script should work for integers, floats, and <code>std::string</code>, but not very robust now. I will continually polish it.</p>
<blockquote>
<p>The same type-catching trick can also be employed in c++ source code. <code>__PRETTY_FUNCTION__</code> macro carries type name of a template function, so you can do some static reflections with it. A famous example is <a target="_blank" rel="noopener" href="https://github.com/Neargye/magic_enum">Magic Enum</a>.</p>
</blockquote>
<p>Another noticeable thing is that public classes of libcxx need special treatment because they have an inline namespace <code>__1</code>.</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar2.png" alt="zaijun"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zaijun</p><p class="is-size-6 is-block">Multimedia SDE</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TsaiHao"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T22:31:16.000Z">2023-03-05</time></p><p class="title"><a href="/blog/Self-Registration-Factory-Pattern-in-Cpp/">Self-Registration Factory Pattern in Cpp</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-18T17:25:19.000Z">2023-02-18</time></p><p class="title"><a href="/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/">Find all simple circles in a directed graph - Johnson Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-04T10:08:01.000Z">2022-12-04</time></p><p class="title"><a href="/blog/implementation_of_libcxx_any/">Introduction to std::any in c++</a></p><p class="categories"><a href="/categories/blog/">blog</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/blog/"><span class="level-start"><span class="level-item">blog</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design-pattern/"><span class="tag">design pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/libc/"><span class="tag">libc++</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.svg" alt="TsaiHao&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Tsai Hao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>