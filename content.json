{"posts":[{"title":"Find all simple circles in a directed graph - Johnson Algorithm","text":"综述Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。 常用的此类算法的复杂度比较如下： Tiernan - O(V.const^V) Tarjan - O(VEC) Johnson - O(((V+E)C) Szwarcfiter and Lauer - O(V+EC) 所谓的简单环，即除了第一个和最后一个顶点，其余所有顶点在路径中只出现一次。这里排除了包括像v-&gt;v这样的自循环的边和在两个顶点之间的多条边的情况。本算法沿用Tiernan算法的记号，每个简单环都是由根顶点为s的子图构建的，这个子图由s和“大于”s的顶点构成。因此每个输出都根据路径的最小点s来分类。 当从s开始遍历路径，把一个顶点v加入这个路径时，会把这个顶点的状态设为“阻塞”（blocked），直到从v到s的所有路径都完成检索，v会一直保持这种状态，这样保证了一个顶点不会被重复添加。另外除非一个顶点是构造简单环路径的最小的点，这个点不会成为路径的根顶点。这样保证不会无意义的搜索。 算法的输入是一个图结构，图的表示是邻接表形式。假设每个顶点用从1到n的一个数字表示，图表示为AG，则AG(v)是一个数组表示第v个顶点的邻接顶点。算法的过程是这样的：从一个根顶点s开始构建简单环，所经过的路径的顶点保存在一个栈中。算法通过调用CIRCUIT过程添加新顶点，添加时务必将其设置为blocked，并且在过程调用返回时删除这个顶点，但是此时不一定将其阻塞状态去除。 代码解析下面是算法的伪代码： 如上所述，整个算法包括CIRCUIT主过程， 位于empty stack;语句以上，它又包含一个子过程UNBLOCK用于对一个blocked顶点进行解锁。下面以C++为例谈一下我对这个算法实现的理解： 每个点的ID表示为1到n的一个类型为size_t整数。Ak，B两个数组在开始时被初始化，数组的长度都为n，即顶点数目。这两个数组的元素都是list，A数组第i个元素的链表记录从点i出发指向的顶点，即图的邻接表。B的作用是记录因为此点阻塞而被迫阻塞的顶点，一旦点i因为调用unblock过程解锁，那么在B[i]链表中记录的顶点也因此解锁。B的效果是将每个点尽可能的保持阻塞状态以防止重复搜索。blocked是一个长度为n的bool数组，表示在搜索时这个点是否是阻塞。s表示目前搜索到的根结点的编号。 CIRCUIT过程从stack v;语句开始，其输入参数v表示这个CIRCUIT过程所搜索的环都是从v这个顶点开始的。调用开始先将标志量f设为false，f表示这次调用是否发现了一个环。把v放在栈stack中，然后将blocked数组的v设为true，即将此点阻塞。可以看到下方对于CIRCUIT的调用都是将s作为参数，所以stack的栈底一般都是s。下一步遍历Ak中第v个链表，即v出发的边指向的顶点。如果某个顶点与s相等，说明找到了一个环，这时执行输出环并把f设为true。否则如果这个顶点没有阻塞，说明还可以向下走，就递归调用此过程。 如果能够在v的邻接顶点中找到一条环路，则f就是true的，这时可以把v解锁，即调用unblock过程。反之，则说明从包含从v出发的边的路径都是死路，是不可能的形成环的，所以不能解锁v，同时要把与v邻接的顶点置于B数组的第v个链表中，经过v的路径是死路，但经过v的邻接顶点w的不一定死路，应为w可能有另外的上级顶点，所以如果不搜索v了，即解锁v顶点是要把B[v]中记录的顶点也解锁，以供其他路径搜索使用。 对v的调用结束时把v出栈。返回f，标志在这次调用中是否发现环。 下面是如何执行主进程。主进程涉及到寻找强连通分量(scc)，这部分可以参考tarjan算法。算法首先清空储存路径节点的栈，将搜寻起点s设为1，注意所有顶点编号从1开始。Ak初始化为在{s, s+1, s+2,…,n}这些顶点构成的子图里面所有强连通分量中，有最小顶点的分量的邻接表。Ak如果为空，说明图已经搜索完，算法结束。否则将s设为上述分量Ak里面最小的顶点，将blocked全置为false，B清空，以s为输入参数调用CIRCUIT。注意此时CIRCUIT只寻找以s开头的环路。调用完成将s加一，再在新的子图中寻找。 实例解析下面是对上述过程的一个实例，来自YouTube一位Tushar Roy的视频主的教程（此君在YouTube上多有图论方面教程，可以学习，这个算法的视频我搬运到了B站，供诸君参考）。Step1是一个有向图G，Step2表示分解后的三个强连通分量，所谓强连通分量，就是在一个有向图中，任选两个顶点都可以互相到达。分解scc的tarjan算法在此不再赘述。发现1是最小的顶点，选取1所在的scc开始搜索，第一个调用顶点是1。step3-5是从1开始的3条遍历路径。上图所示，红色边表示搜索的路径，从1开始依次搜索1，2，3，到3的时候，栈里存储了这三个节点，并且blocked数组将这三个元素设为true。3有3个邻接顶点。首先搜索1，发现1是出发的顶点，表明找到了一个环，就将环输出，并把3这里调用的变量f设为true。回到顶点3后搜索下一个邻接顶点4，4没有阻塞说明还没有探索过，4只有一个邻接点5，走到5之后已经无路可走，因为5的唯一邻接顶点2处于blocked状态，所以以f为false返回这次调用，表明没有找到环。调用从2返回到5的时候看到返回值是false，这时把5放到B[2]的链表中。这种做法相当于告诉2节点：兄弟你解锁的时候把我也解锁了，你不解锁我也堵着算了，反正下次再找到我的时候，我的下家都是死路，找也是白找。所以，只有在调用UNBLOCK(2)的时候5才能解锁，这时blocked[5]还是保持blocked状态。返回的4的时候也是如此。需要把4保持阻塞，并把4放到B[5]的链表中。这时调用返回到了3节点。检索3的下一个邻居6，发现6的下家4还是阻塞的，于是这次调用也以失败返回。返回到3，3的邻居已经检索完，发现了一个环，所以f是true的，把3的阻塞解除，调用返回到2。因为3找到了一个环所以2的f也是true的，所以调用UNBLOCK(2)，这个过程把blocked[2]设为false之后，检索B[2]发现里面有一个元素5，因此递归调用把5也解锁了。依次调用，B就被清空了。 这就是一次1-&gt;2这个边开头的检索的完整过程。 引用[1] Donald B. Johnson, Finding all the elementary circuits of a directed graph, SIAM Journal on Computing, 1975. [2] BiliBili搬运视频：https://www.bilibili.com/video/BV13Q4y1K7bx [3] 一个Github的C++实现：https://github.com/hellogcc/circuit-finding-algorithm（其实现无论方式还是算法都有不少和原算法的出入，大家批判性鉴赏。","link":"/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/"},{"title":"Introduction to std::any in c++","text":"What Is std::anystd::any is a new feature that comes with C++ 17 standard. It’s kind of void* with type-safety, supporting copy/move/store/get, etc. Some basic usages of it can be found here: std::any - cppreference Understanding how std::any is implemented can be gainful, for it taking advantage of many c++ skills, especially templates. Implementation of std::anyThe source code referred to below is of llvm’s libcxx library, revision: any - libcxx. Class Layoutstd::any has two data members: __h_: _HandleFunPtr, it’s a function pointer that points to a static function, as well as the entry of data manipulation including constructing/destroying/copying/access, etc. Prototype of the function is: 123456789/******** arg1: Enum, kind of the manipulation, (_Destroy, _Copy, _Move, _Get, _TypeInfo)* arg2: Caller's &quot;this&quot; pointer* arg3: Destination any, used in copy, move* arg4: Runtime type info, always nullptr if rtti is disabled* arg5: Fallback type info, described in next chapter*******/using _HandleFuncPtr = void* (*)(_Action, any const *, any *, const type_info *, const void* __fallback_info); __s_: _Storage, stores pointer to managing data. It’s declared as a union for separately handling large and small objects. In conclusion, std::any is basically equal to an aggregate of a data block and a predefined manipulation function, which proves the famous saying Algorithms + Data Structures = Programs to some extent. Skills of ImplementationSmall objects optimization Implementations are encouraged to avoid dynamic allocations for small objects. – cpp refrence The data pointer __s_ is not a void* but privately declared as a such union: 123456using _Buffer = aligned_storage_t&lt;3*sizeof(void*), alignment_of&lt;void*&gt;::value&gt;;union _Storage { constexpr _Storage() : __ptr(nullptr) {} void * __ptr; __any_imp::_Buffer __buf;}; In a 64-bit machine, _Storage occupies 24 bytes. __buf is equally a void*, used when the contained object is no larger than 24 bytes. Utilizing the benefits of stack memory, constructing or copying these small objects could be more effective. Larger objects, on the other hand, have to be stored on heap memory and allocated dynamically in runtime. “24 bytes” is a curated threshold that is exactly the size of std::vector /std::string and many other STL containers in libcxx. This fact means std::any can manage these common objects faster, though the memory inside them could still be dynamic. A similar memory optimization technology is also applied on std::string, but subtler. I will introduce it in the future. In-place ConstructWhen a std::any object is copied, the object managed by it is also copied. It’s pretty straight yet important, simply memcpy is not enough because some classes have essential things to do, such as std::shared_ptr. std::anys copy object with its own copy constructor through allocator. It also applies to move construction. But what about the constructor itself? Like emplace_back for std::vector, std::any also has an emplace-like constructor, in which the object is directly constructed on __buf instead of constructing a temporary object and then moving it. 12std::any a(std::in_place_type&lt;std::string&gt;, &quot;hello&quot;);std::any b(&quot;hello&quot;); By inspecting these 2 variables in a debugger, we can acknowledge that std::in_place_type&lt;std::string&gt; has two folder meanings, it tells std::any constructing a std::string instead of a const char* and constructing it directly. Type to int mappingObviously, std::any is not a template class itself, but it can throw exceptions when casting it to a different static type even if RTTI(run-time type info) is disabled. The secret of this type-safety is a mapping from type to an integer. On line 162 of any.h, a type-unique template struct is defined as: 12345678910template &lt;class _Tp&gt;struct __unique_typeinfo { static constexpr int __id = 0; };// get type id if rtti is disabledtemplate &lt;class _Tp&gt;inline constexpr const void* __get_fallback_typeid() { return &amp;__unique_typeinfo&lt;remove_cv_t&lt;remove_reference_t&lt;_Tp&gt;&gt;&gt;::__id;} The static member __id of __unique_typeinfo is always equal to 0 but is a unique instance corresponding to type __Tp due to template specialization. Based on this, std::any gets the address of __id as a fallback type id if RTTI is disabled (compiling with flag -fno-rtti). Best PracticesIn conclusion, the best practices of std::any include: To avoid unnecessary copying, use std::make_any or std::in_place_type to construct. Pass std::any by reference if possible. Use pointer version std::any_cast&lt;T&gt;(&amp;a) to avoid copying large objects. Let custom objects conform to the rule of three/five/zero if managed by std::any. Formatting of std::any in LLDBBoth belonging to Project LLVM, LLDB does not provide a formatted display of std::any of libcxx (while GDB does with libstdc++). Printing std::any in LLDB CLI will get: 12345678910111213141516(lldb) nProcess 76235 stopped* thread #1, queue = 'com.apple.main-thread', stop reason = step over frame #0: 0x0000000100003a3c Play`main at main.cpp:17:5 14 int main() { 15 std::any a = 1;-&gt; 16 return 0; 17 }(lldb) fr v a(std::any) $0 = { __h = 0x0000000100003d2c (Play`std::__1::__any_imp::_SmallHandler&lt;int&gt;::__handle(std::__1::__any_imp::_Action, std::__1::any const*, std::__1::any*, std::type_info const*, void const*) at any:350) __s = { __ptr = 0x0000000000000001 __buf = (__lx = &quot;\\U00000001\\0\\0\\0\\0\\0\\0\\0\\U00000001\\0\\xc1\\x89FͽV\\0:\\0\\0\\U00000001&quot;) }} It takes seconds to understand “a” is an int (from _SmallHandler’s type) and its value is 0x1 (from first 4 bytes of __buf). I write a Python script as a plugin based on LLDB API to print it more intuitively. Implementation of pluginThere are 2 functions inside this script. __lldb_init_module is the entry of this plugin. handle_std_any is the processing handle used by LLDB. A tricky skill is catching the type name inside _SmallHandler using regex. After knowing that, we can find the object representing this type in python and then forcibly convert the pointer of buffer to it. This script should work for integers, floats, and std::string, but not very robust now. I will continually polish it. The same type-catching trick can also be employed in c++ source code. __PRETTY_FUNCTION__ macro carries type name of a template function, so you can do some static reflections with it. A famous example is Magic Enum. Another noticeable thing is that public classes of libcxx need special treatment because they have an inline namespace __1.","link":"/blog/implementation_of_libcxx_any/"},{"title":"Self-Registration Factory Pattern in Cpp","text":"Self-Registration Factory Pattern in C++Usage ScenariosImplementing a typical factory pattern in C++ is not complicated, take the common Shape class as an example: 12345678910// ShapeFactory.cpp#include &quot;Shape.h&quot; // class Shape#include &quot;Triangle.h&quot; // class Triangle: public Shape#include &quot;Circle.h&quot; // class Circle: public Shapestd::unique_ptr&lt;Shape&gt; createShape(std::string_view name) { if (name == &quot;triangle&quot;) return std::unique_ptr&lt;Shape&gt;(new Triangle()); else if (name == &quot;circle&quot;) return std::unique_ptr&lt;Shape&gt;(new Circle()); else return nullptr;} This method is pretty straightforward and is used more, but there are two disadvantages: Each concrete class implementation must be manually registered in the ShapeFactory.cpp . Over time, this file will be longer and there will be too many if-else branches eventually; It is not easy to do isolation of function macros, and there will be nesting of preprocessor commands with poor readability after adding platform macros. You can dynamically generate list files such as codec_list .cin FFmpeg to solve the second problem. As a cross-platform library, FFmpeg faces the very same problem of more complex functional options. Its solution is to dynamically generate this list file for as long as possible during the configuration time. Only the enabled codec will appear in the list, which looks relatively clean. This article will introduce another way to solve the above two problems: the self-registered factory pattern. Implementation and PrinciplesSelf-registration exploits the global static variable or class static member automatic initialization mechanism. In the constructor of a static variable, it will register itself into the factory method implicitly. C programming language can achieve a similar effect through __attribute__ ((constructor)) . For example, the Shape example above can be written as: registry.h 1234567template &lt;typename ShapeType&gt;bool registerShape(std::string_view name) { ShapeFactory::instance().registerShape(name, []() { return std::unique_ptr&lt;Shape&gt;(new ShapeType()); }); return true;} circle.cpp 123456789101112131415class Circle: public Shape {public: Circle() = default; double area() const override;private: double m_radius = 0; static bool m_registered;};bool Circle::m_registered = registerShape&lt;Circle&gt;(&quot;Circle&quot;);double Circle::area() const { return 3.14 * m_radius * m_radius;} Circle::m_registered is only used to collect the return value of the registered function and ensure that it is called. The registered function call occurs before entering the main function. After entering the main function, you can directly use the factory class to create an instance. main.cpp 12345678int main() { auto shape = ShapeFactory::instance().createShape(&quot;Circle&quot;); if (shape) std::cout &lt;&lt; &quot;shape created&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;shape not found&quot; &lt;&lt; std::endl; return 0;} The advantage of this is obvious, since the registration of the creator takes place in the Circle source file. If we decide to disable the Circle class through the feature option, just rule out this file in the build file, no need to modify the code elsewhere, and no need to set up some functional macros to isolate the code. We don’t even need to declare Circle in a header file since there is no direct reference to this class anywhere else! This method is also highly suitable for dynamic loading plug-ins during runtime. Suppose the Circle class is designed as a plug-in, the host program only needs to invoke dlopen function to load the Circle.so, and it will register itself into the list without any additional need for read information methods. The sample code above can be found in different branches here: TsaiHao/SelfRegisterFactory But this approach also inherently has some problems that are not easy to ignore. The following will introduce its shortcomings and some compromise methods. Problems in PracticeSymbol Stripping of Static LinkingThis is the most direct problem with the self-registration method, as the cost of implementing the code unitization above. For a static library, the linker only copies the object files directly used by the program during the linking phase. Therefore, the above Circle.o object file will be removed without notifying because the Circle class has no code reference other than itself! When we have to use static linking without giving up the self-registration method, we can: Use some compile options to force the link target to depend on self-registered symbols, in clang / gcc , this option is -u, see Clang command line argument reference - Clang 17.0.0git documentation . In the above example, add an INTERFACE link option to the shape class in CMake : 1target_link_options(shape INTERFACE -u__ZN6Circle12m_registeredE) After that, any target links libshape.a library will default rely on Circle:: m_registerd, thereby forcing the linker to use Circle.o object file. Directly make the self-registered source file participate in the compilation of the upper-level target, that is, not compress Circle.o into the libshape.a library, but directly link the object file to the upper-level target as an additional subsidiary of the library. The implementation of CMake is: 1target_sources(shape INTERFACE ${CMAKE_CURRENT_LIST_DIR}/shape/impl/Circle.cpp) In this way, all the targets that link the shape library will directly use Circle.cpp as their own source files so that the linker will not directly delete a target file such as Circle.o. The above two methods are highly dependent on the compilation and CMake system. If you need cross-platform you need a more general method which I have not found yet. The Construction Order of Static VariablesBecause the factory uses global variables to register, you must be careful not to rely on their order, and the relevant operations should be carried out after entering the main function as much as possible, for example: The map that holds the creator in the Factory must be a static variable in the function scope instead of the global scope; Do not create or refer to this factory in the construction of other static variables. Who Are Using ThisClang’s plugins and various modules of clang-tidy in Project LLVM use this technique: Clang plugin, see Clang Plugins - Clang 17.0.0git documentation , dynamically loaded by dlopen at runtime, after loading, the actions in the plugin are automatically registered into the list, and there is no problem with symbol elimination. Clang-tidy module registration. A new module is registered by initializing a static variable. to solve the above problem, clang-tidy declares an extern volatile int variable corresponding to each module in a public header file, and the definition of the variable instance is distributed in the module’s source file. Because of the reference of this int variable, the corresponding module will not be removed by default.","link":"/blog/Self-Registration-Factory-Pattern-in-Cpp/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"libc++","slug":"libc","link":"/tags/libc/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"}],"pages":[{"title":"","text":"Hao ZaijunAbout meMy name is Hao Zaijun. I graduated from Shandong University with a master’s degree in biomedical engineering. I now work in Bytedance as a multimedia software development engineer. My main interested research areas are Software Architecture, Multimedia Software, Computer Graphics, and Programming Languages (C/C++, Python, etc).","link":"/index.html"}]}