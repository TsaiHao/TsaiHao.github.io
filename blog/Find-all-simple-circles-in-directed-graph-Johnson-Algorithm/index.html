<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Find all simple circles in a directed graph - Johnson Algorithm - TsaiHao&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TsaiHao&#039;s Blog"><meta name="msapplication-TileImage" content="/images/logo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TsaiHao&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="综述Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。 常用的此类算法的复杂度比较如下：  Tiernan - O(V.const^V) Tarjan - O(VEC) Johnso"><meta property="og:type" content="article"><meta property="og:title" content="Find all simple circles in a directed graph - Johnson Algorithm"><meta property="og:url" content="https://tsaihao.github.io/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/"><meta property="og:site_name" content="TsaiHao&#039;s Blog"><meta property="og:description" content="综述Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。 常用的此类算法的复杂度比较如下：  Tiernan - O(V.const^V) Tarjan - O(VEC) Johnso"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tsaihao.github.io/images/johnson_pseudo_code.png"><meta property="og:image" content="https://tsaihao.github.io/images/johnson_step_1.png"><meta property="og:image" content="https://tsaihao.github.io/images/johnson_step_2.png"><meta property="og:image" content="https://tsaihao.github.io/images/johnson_step_3.png"><meta property="og:image" content="https://tsaihao.github.io/images/johnson_step_4.png"><meta property="article:published_time" content="2023-02-18T17:25:19.000Z"><meta property="article:modified_time" content="2023-02-19T05:23:58.986Z"><meta property="article:author" content="Tsai Hao"><meta property="article:tag" content="algorithm"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tsaihao.github.io/images/johnson_pseudo_code.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tsaihao.github.io/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/"},"headline":"Find all simple circles in a directed graph - Johnson Algorithm","image":["https://tsaihao.github.io/images/johnson_pseudo_code.png","https://tsaihao.github.io/images/johnson_step_1.png","https://tsaihao.github.io/images/johnson_step_2.png","https://tsaihao.github.io/images/johnson_step_3.png","https://tsaihao.github.io/images/johnson_step_4.png"],"datePublished":"2023-02-18T17:25:19.000Z","dateModified":"2023-02-19T05:23:58.986Z","author":{"@type":"Person","name":"Tsai Hao"},"publisher":{"@type":"Organization","name":"TsaiHao's Blog","logo":{"@type":"ImageObject","url":"https://tsaihao.github.io/images/logo.svg"}},"description":"综述Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。 常用的此类算法的复杂度比较如下：  Tiernan - O(V.const^V) Tarjan - O(VEC) Johnso"}</script><link rel="canonical" href="https://tsaihao.github.io/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/"><link rel="icon" href="/images/logo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.svg" alt="TsaiHao&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/TsaiHao"><i class="zaijun&#039;s github"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-02-18T17:25:19.000Z" title="2/18/2023, 5:25:19 PM">2023-02-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-02-19T05:23:58.986Z" title="2/19/2023, 5:23:58 AM">2023-02-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile">Find all simple circles in a directed graph - Johnson Algorithm</h1><div class="content"><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Johnson算法由B. Johnson发表于1975年，用于在一个有向图中寻找所有简单环。时间复杂度上界为O((n+e)(c+1))，空间复杂度为O(n+e)，其中n为顶点数，e为边数，c为存在环数。在算法执行时，每两个连续的环的输出之间的时间不会超过O(n+e)。</p>
<p><em>常用的此类算法的复杂度比较如下：</em></p>
<ul>
<li>Tiernan - O(V.const^V)</li>
<li>Tarjan - O(VEC)</li>
<li>Johnson - O(((V+E)C)</li>
<li>Szwarcfiter and Lauer - O(V+EC)</li>
</ul>
<p>所谓的简单环，即除了第一个和最后一个顶点，其余所有顶点在路径中只出现一次。这里排除了包括像v-&gt;v这样的自循环的边和在两个顶点之间的多条边的情况。本算法沿用Tiernan算法的记号，每个简单环都是由根顶点为s的子图构建的，这个子图由s和“大于”s的顶点构成。因此每个输出都根据路径的最小点s来分类。</p>
<p>当从s开始遍历路径，把一个顶点v加入这个路径时，会把这个顶点的状态设为“阻塞”（blocked），直到从v到s的所有路径都完成检索，v会一直保持这种状态，这样保证了一个顶点不会被重复添加。另外除非一个顶点是构造简单环路径的最小的点，这个点不会成为路径的根顶点。这样保证不会无意义的搜索。</p>
<p>算法的输入是一个图结构，图的表示是邻接表形式。假设每个顶点用从1到n的一个数字表示，图表示为AG，则AG(v)是一个数组表示第v个顶点的邻接顶点。算法的过程是这样的：从一个根顶点s开始构建简单环，所经过的路径的顶点保存在一个栈中。算法通过调用CIRCUIT过程添加新顶点，添加时务必将其设置为blocked，并且在过程调用返回时删除这个顶点，但是此时不一定将其阻塞状态去除。</p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><p>下面是算法的伪代码：<br><img src="/images/johnson_pseudo_code.png"></p>
<p>如上所述，整个算法包括CIRCUIT主过程， 位于empty stack;语句以上，它又包含一个子过程UNBLOCK用于对一个blocked顶点进行解锁。下面以C++为例谈一下我对这个算法实现的理解：</p>
<p>每个点的ID表示为1到n的一个类型为size_t整数。Ak，B两个数组在开始时被初始化，数组的长度都为n，即顶点数目。这两个数组的元素都是list<size_t>，A数组第i个元素的链表记录从点i出发指向的顶点，即图的邻接表。B的作用是记录因为此点阻塞而被迫阻塞的顶点，一旦点i因为调用unblock过程解锁，那么在B[i]链表中记录的顶点也因此解锁。B的效果是将每个点尽可能的保持阻塞状态以防止重复搜索。blocked是一个长度为n的bool数组，表示在搜索时这个点是否是阻塞。s表示目前搜索到的根结点的编号。</p>
<p>CIRCUIT过程从stack v;语句开始，其输入参数v表示这个CIRCUIT过程所搜索的环都是从v这个顶点开始的。调用开始先将标志量f设为false，f表示这次调用是否发现了一个环。把v放在栈stack中，然后将blocked数组的v设为true，即将此点阻塞。可以看到下方对于CIRCUIT的调用都是将s作为参数，所以stack的栈底一般都是s。下一步遍历Ak中第v个链表，即v出发的边指向的顶点。如果某个顶点与s相等，说明找到了一个环，这时执行输出环并把f设为true。否则如果这个顶点没有阻塞，说明还可以向下走，就递归调用此过程。</p>
<p>如果能够在v的邻接顶点中找到一条环路，则f就是true的，这时可以把v解锁，即调用unblock过程。反之，则说明从包含从v出发的边的路径都是死路，是不可能的形成环的，所以不能解锁v，同时要把与v邻接的顶点置于B数组的第v个链表中，经过v的路径是死路，但经过v的邻接顶点w的不一定死路，应为w可能有另外的上级顶点，所以如果不搜索v了，即解锁v顶点是要把B[v]中记录的顶点也解锁，以供其他路径搜索使用。</p>
<p>对v的调用结束时把v出栈。返回f，标志在这次调用中是否发现环。</p>
<p>下面是如何执行主进程。主进程涉及到寻找强连通分量(scc)，这部分可以参考tarjan算法。算法首先清空储存路径节点的栈，将搜寻起点s设为1，注意所有顶点编号从1开始。Ak初始化为在{s, s+1, s+2,…,n}这些顶点构成的子图里面所有强连通分量中，有最小顶点的分量的邻接表。Ak如果为空，说明图已经搜索完，算法结束。否则将s设为上述分量Ak里面最小的顶点，将blocked全置为false，B清空，以s为输入参数调用CIRCUIT。注意此时CIRCUIT只寻找以s开头的环路。调用完成将s加一，再在新的子图中寻找。</p>
<h2 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h2><p>下面是对上述过程的一个实例，来自YouTube一位Tushar Roy的视频主的教程（此君在YouTube上多有图论方面教程，可以学习，这个算法的视频我搬运到了B站，供诸君参考）。<br><img src="/images/johnson_step_1.png"><br>Step1是一个有向图G，Step2表示分解后的三个强连通分量，所谓强连通分量，就是在一个有向图中，任选两个顶点都可以互相到达。分解scc的tarjan算法在此不再赘述。<br><img src="/images/johnson_step_2.png"><br>发现1是最小的顶点，选取1所在的scc开始搜索，第一个调用顶点是1。step3-5是从1开始的3条遍历路径。上图所示，红色边表示搜索的路径，从1开始依次搜索1，2，3，到3的时候，栈里存储了这三个节点，并且blocked数组将这三个元素设为true。3有3个邻接顶点。首先搜索1，发现1是出发的顶点，表明找到了一个环，就将环输出，并把3这里调用的变量f设为true。<br><img src="/images/johnson_step_3.png"><br>回到顶点3后搜索下一个邻接顶点4，4没有阻塞说明还没有探索过，4只有一个邻接点5，走到5之后已经无路可走，因为5的唯一邻接顶点2处于blocked状态，所以以f为false返回这次调用，表明没有找到环。调用从2返回到5的时候看到返回值是false，这时把5放到B[2]的链表中。这种做法相当于告诉2节点：兄弟你解锁的时候把我也解锁了，你不解锁我也堵着算了，反正下次再找到我的时候，我的下家都是死路，找也是白找。所以，只有在调用UNBLOCK(2)的时候5才能解锁，这时blocked[5]还是保持blocked状态。返回的4的时候也是如此。需要把4保持阻塞，并把4放到B[5]的链表中。这时调用返回到了3节点。<br><img src="/images/johnson_step_4.png"><br>检索3的下一个邻居6，发现6的下家4还是阻塞的，于是这次调用也以失败返回。返回到3，3的邻居已经检索完，发现了一个环，所以f是true的，把3的阻塞解除，调用返回到2。因为3找到了一个环所以2的f也是true的，所以调用UNBLOCK(2)，这个过程把blocked[2]设为false之后，检索B[2]发现里面有一个元素5，因此递归调用把5也解锁了。依次调用，B就被清空了。</p>
<p>这就是一次1-&gt;2这个边开头的检索的完整过程。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] Donald B. Johnson, Finding all the elementary circuits of a directed graph, SIAM Journal on Computing, 1975.</p>
<p>[2] BiliBili搬运视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y1K7bx">https://www.bilibili.com/video/BV13Q4y1K7bx</a></p>
<p>[3] 一个Github的C++实现：<a target="_blank" rel="noopener" href="https://github.com/hellogcc/circuit-finding-algorithm%EF%BC%88%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%97%A0%E8%AE%BA%E6%96%B9%E5%BC%8F%E8%BF%98%E6%98%AF%E7%AE%97%E6%B3%95%E9%83%BD%E6%9C%89%E4%B8%8D%E5%B0%91%E5%92%8C%E5%8E%9F%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E5%85%A5%EF%BC%8C%E5%A4%A7%E5%AE%B6%E6%89%B9%E5%88%A4%E6%80%A7%E9%89%B4%E8%B5%8F%E3%80%82">https://github.com/hellogcc/circuit-finding-algorithm（其实现无论方式还是算法都有不少和原算法的出入，大家批判性鉴赏。</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/algorithm/">algorithm</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog/Self-Registration-Factory-Pattern-in-Cpp/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Self-Registration Factory Pattern in C++</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/implementation_of_libcxx_any/"><span class="level-item">Introduction to std::any in C++</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/avatar2.png" alt="zaijun"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zaijun</p><p class="is-size-6 is-block">Multimedia SDE</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TsaiHao"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T22:31:16.000Z">2023-03-05</time></p><p class="title"><a href="/blog/Self-Registration-Factory-Pattern-in-Cpp/">Self-Registration Factory Pattern in C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-18T17:25:19.000Z">2023-02-18</time></p><p class="title"><a href="/blog/Find-all-simple-circles-in-directed-graph-Johnson-Algorithm/">Find all simple circles in a directed graph - Johnson Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-04T18:08:01.000Z">2022-12-04</time></p><p class="title"><a href="/blog/implementation_of_libcxx_any/">Introduction to std::any in C++</a></p><p class="categories"><a href="/categories/blog/">blog</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/blog/"><span class="level-start"><span class="level-item">blog</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design-pattern/"><span class="tag">design pattern</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/libc/"><span class="tag">libc++</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.svg" alt="TsaiHao&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Tsai Hao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>